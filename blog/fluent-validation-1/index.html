<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script><script src="https://kit.fontawesome.com/943e35d59f.js" crossorigin="anonymous"></script><meta name="generator" content="Gatsby 3.11.1"/><link as="script" rel="preload" href="/webpack-runtime-7ef62aaed3d55b60f0f0.js"/><link as="script" rel="preload" href="/framework-5b220df2207acdd267a3.js"/><link as="script" rel="preload" href="/app-5faed1a32dbc85b94cce.js"/><link as="script" rel="preload" href="/component---src-pages-markdown-remark-frontmatter-slug-js-1bc9521777f43783db70.js"/><link as="fetch" rel="preload" href="/page-data/blog/fluent-validation-1/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><main><title>U Raval | <!-- -->Starting from Scratch: Fluent Validation</title><nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class="container-fluid"><a class="navbar-brand" href="/"><img src="/unalome.png" width="24" height="24" class="d-inline-block align-text-top mr-2"/><span class="pl-3">Ushir (Rishi) Raval</span></a><ul class="navbar-nav"><li class="nav-item"><a class="nav-link" href="https://github.com/urishiraval"><i class="fab fa-github"></i></a></li><li class="nav-item"><a class="nav-link" href="https://www.linkedin.com/in/unraval/"><i class="fab fa-linkedin-in"></i></a></li><li class="nav-item"><a class="nav-link" href="https://www.instagram.com/rishi_raval7/"><i class="fab fa-instagram"></i></a></li></ul></div></nav><div class="container my-5"><div class="row justify-content-center px-5"><h1 class="white fancy-font text-center">Starting from Scratch: Fluent Validation</h1><h2 class="white text-center">August 23, 2021</h2><div class="white mt-5"><h1>Starting from Scratch: Fluent Validation</h1>
<h2>Brief</h2>
<p>The main goal of fluent validation seems to be the separation of highly conditional branching trees into it's own layer in very dynamic systems. So far the only system that I've worked on where this would be of great benefit are business/financial applications with a ton of business/product rules and while ideally you'd want those rules to be evaluated in the back-end I think that the front-end (especially if it's a monolithic front end, which is often the case in that environment) can get very dense with dynamic content depending on those rules.</p>
<p>I'm still searching for the "simplest form of this" with the "most substantial outcome" as Liebniz describes it, but I think that fluent validation is the strongest contender so far.</p>
<p>In an attempt to further understand how fluent validation works in javascript, I tried to recreate an extremely basic chain-able system from scratch. What follows is a rough transcript of my journey.</p>
<h2>Understanding the Basics</h2>
<p>First, I researched different ways that function chaining was accomplished and ultimately found <a href="https://stackoverflow.com/questions/35026609/chain-custom-javascript-functions">this Stackoverflow post</a> from 2016. In that post I found that there are 2 basic approuches that are pretty much similar in concept but with slightly different executions.</p>
<h3>Chaining in Javascript</h3>
<p>Before that however, I needed to define what was the minium requirement for a function to be chained. So this:</p>
<pre><code class="language-javascript">function chainableX () {
    console.log("Executing X");
    return this;
}

function chainableY() {
    console.log("Executing Y");
    return this;
}
</code></pre>
<p>Would allow us to 'chain' like this:</p>
<pre><code class="language-javascript">var context = chainableX().chainableY();
</code></pre>
<pre><code>Executing X
Executing Y
</code></pre>
<p>Where the resulting <code>context</code> variable would be the global call stack since these functions don't belong to any object.So, with that, returning <code>this</code> I could now chain functions.</p>
<h3>Accumulating Side-effects within a Scope</h3>
<p>The next task was to allow for side effects to accumulate in a sequential manner. My initial thoughts were that this was very similar to a 'Builder' design pattern and indeed, when I glanced at the source code of some common validation packages, that seemed to be a solution that was used. However, in my attempt to keep things as simple as I possibly can, along with trying to use vanilla js and functional-ish concepts as much as I can, I opted for a slightly different approach, (but one that was not necessarily better by any metric).</p>
<p>My first attempt was to create an 'object' based solution that would accumulate the side effects on a variable within that context. So I thought that the initial object would somehow resemble this:</p>
<pre><code class="language-javascript">check = {
    result: null,
    not: function() {
        this.result = !this.result;
        return this;
    },
    or: function() {
        return this;
    },
    and: function() {
        return this;
    },
    t: function() {
        return this;
    },
    f: function() {
        return this;
    }
}

console.log(check.not().f().and().t().result);
</code></pre>
<pre><code>true
</code></pre>
<h3>Chaining of Boolean Operators</h3>
<p>I quickly realised that I'd have a glaring problem. The operators <code>AND</code> and <code>OR</code> are binary and while this gives the example chain above a 'space' to accumulate results, you can't accumulate a binary operator without 'embedding' values similar to <code>check.not().and(&#x3C;exp>)</code>, which was not what I wanted.</p>
<p>So in order to solve this problem I decided to borrow from my Compiler Construction course in University by adding very basic 'lookahead' functionality.</p>
<p>Fundamentally, what this lookahead function would do is defer the binary operation until a subsequent unary operation has a result (kind of like the 'Chain of responsibility' design pattern). This is a bit of a dodgy solution which, I think, only works because chaining multiple binary operations have no value in a validation, i.e. <code>and().and().t()</code> makes no logical sense in boolean terms and adds no functional value.</p>
<p>So, adding this lookahead function as _la and just concentrating on <code>AND</code>, we get the following:</p>
<pre><code class="language-javascript">check = {
    _la: null,
    and: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw "Chaining multiple binary operators is not allowed";
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result; 
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res &#x26;&#x26; exp;
        };
        return this;
    }
}
</code></pre>
<p>Adding some 'constants' like true and false, along with a 'default lookahead' function in order to cater for when our lookahead is null we get:</p>
<pre><code class="language-javascript">check = {
    _la: null,
    _defaultLa: function(exp) {
        //Just pass through the value 
        return exp;
    },
    and: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw "Chaining multiple binary operators is not allowed";
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result; 
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res &#x26;&#x26; exp;
        };
        return this;
    },
    tautology: function() {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(true);
        this._la = null;
        return this;
    },
    fallacy: function () {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(false);
        this._la = null;
        return this;
    }
}

console.log(check.tautology().and().tautology().result);
</code></pre>
<pre><code>true
</code></pre>
<p>All that is left to do is to extend this concept to the <code>OR</code> and <code>NOT</code> operators. However the <code>NOT</code> operator, despite being a unary operator, still needs to be implemented as a deferred operation since we're negating the result of the operation after it, i.e. we need it to look like <code>not().operation()</code>.</p>
<p>The resulting snippet becomes:</p>
<pre><code class="language-javascript">check = {
    result: null,
    _la: null,
    _defaultLa: function(exp) {
        //Just pass through the value 
        return exp;
    },
    not: function() {
        var eval = (this._la) ? this._la : this._defaultLa;
        var res = this.result;
        this._la = function(exp) {
            //We pass in eval to the function stack by taking advantage of javascript closures
            return eval(!exp);
        }
        return this;
    },
    and: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw "Chaining multiple binary operators is not allowed";
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result; 
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res &#x26;&#x26; exp;
        };
        return this;
    },
    or: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw "Chaining multiple binary operators is not allowed";
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result; 
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res || exp;
        };
        return this;
    },
    tautology: function() {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(true);
        this._la = null;
        return this;
    },
    fallacy: function () {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(false);
        this._la = null;
        return this;
    }
}

console.log(check.fallacy().or().not().fallacy().result);
</code></pre>
<pre><code>true
</code></pre>
<p>And there you have it. This is a working, chainable, admittedly ultra-basic fluent validator that you can extent by adding more operators and dependant objects etc.</p>
<h3>Final Product</h3>
<p>However, to make it a bit more usable and extendable I thought converting this to a context-full, generic-ish object would be better:</p>
<pre><code class="language-javascript">function fcheck() {
        this.result = null;
        this._la = null;
        this._defaultLa = function(exp) {
            return exp;
        };
        this._preval = function (exp) {
            var eval = (this._la) ? this._la : this._defaultLa;
            this.result = eval(exp);
        };
        this.not = function() {
            var eval = (this._la) ? this._la : this._defaultLa;
            this._la = function(exp) {
                //We pass in eval to the function stack by taking advantage of javascript closures
                return eval(!exp);
            }
            return this;
        };
        this.or = function() {
            if (this._la) throw "Chaining multiple binary operators is not allowed";
            let res = this.result;
            this._la = function(exp) {
                return res || exp;
            }
            return this;
        };
        this.and = function() {
            if (this._la) throw "Chaining multiple binary operators is not allowed";
            let res = this.result;
            this._la = function(exp) {
                return res &#x26;&#x26; exp;
            };
            return this;
        };
        this.tautology = function() {
            this._preval(true);
            this._la = null;
            return this;
        };
        this.fallacy = function() {
            this._preval(false);
            this._la = null;
            return this;
        }
}

</code></pre>
<p>This allows us to dynamically add rules on the fly by adding to the object, this function:</p>
<pre><code class="language-javascript">fcheck.prototype.addRule = function (ruleName, rule) {
    var acc = this;
    this[ruleName] = function () {
        this._preval(rule());
        return acc;
    }
    return this;
}
</code></pre>
<p><strong>So the final version:</strong></p>
<pre><code class="language-javascript">
function fcheck() {
        this.result = null;
        this._la = null;
        this._defaultLa = function(exp) {
            return exp;
        };
        this._preval = function (exp) {
            var eval = (this._la) ? this._la : this._defaultLa;
            this._la = null;
            this.result = eval(exp);
        };
        this.not = function() {
            var eval = (this._la) ? this._la : this._defaultLa;
            this._la = function(exp) {
                return eval(!exp);
            }
            return this;
        };
        this.or = function() {
            if (this._la) throw "Chaining multiple binary operators is not allowed";
            let res = this.result;
            this._la = function(exp) {
                return res || exp;
            }
            return this;
        };
        this.and = function() {
            if (this._la) throw "Chaining multiple binary operators is not allowed";
            let res = this.result;
            this._la = function(exp) {
                return res &#x26;&#x26; exp;
            };
            return this;
        };
        this.tautology = function() {
            this._preval(true);
            return this;
        };
        this.fallacy = function() {
            this._preval(false);
            return this;
        }
}

fcheck.prototype.addRule = function (ruleName, rule) {
    var acc = this;
    this[ruleName] = function () {
        this._preval(rule());
        return acc;
    }
    return this;
}
</code></pre>
<p>And this object can be used like so:</p>
<pre><code class="language-javascript">var scenario = new fcheck();
scenario.addRule("myFunction", function () {
    return true;
});

scenario.not().myFunction().and().fallacy().result;
</code></pre>
<pre><code>false
</code></pre>
<p>This also allows us to compose complex validations, for example:</p>
<pre><code class="language-javascript">
var flagA = true;
var flagB = false;

var Rule1 = new fcheck().addRule("isScenarioA", function () {
    return flagA == true;
});
var Rule2 = new fcheck().addRule("isScenarioA", function () {
    return flagB == true;
});

var BusinessValidations = new fcheck().addRule('rule1', function () {
    return Rule1.isScenarioA().result;
})
.addRule('rule2', function () {
    return Rule2.isScenarioA().result;
});
</code></pre>
<pre><code class="language-javascript">BusinessValidations.rule1().and().rule2().result;
</code></pre>
<pre><code>false
</code></pre>
<pre><code class="language-javascript">BusinessValidations.rule1().and().not().rule2().result;
</code></pre>
<pre><code>true
</code></pre>
<p>And that's it. Thanks for sticking around to this sentence. If you, the reader, has any thoughts on this implementation or a better way to do this (besides just using a library...I do know that I can and that's not the point here), please do reach out and let me know on my socials found somewhere above.</p></div></div></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/fluent-validation-1/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-333b796d788154d0324b.js"],"app":["/app-5faed1a32dbc85b94cce.js"],"component---src-pages-404-js":["/component---src-pages-404-js-8563cd8ae9d71a95de07.js"],"component---src-pages-blog-tsx":["/component---src-pages-blog-tsx-ca075422bfa110579240.js"],"component---src-pages-index-js":["/component---src-pages-index-js-8c809efe1ce6d5a9302b.js"],"component---src-pages-markdown-remark-frontmatter-slug-js":["/component---src-pages-markdown-remark-frontmatter-slug-js-1bc9521777f43783db70.js"],"component---src-pages-navbar-tsx":["/component---src-pages-navbar-tsx-f1b44bbae6692a4a161c.js"],"component---src-pages-projects-tsx":["/component---src-pages-projects-tsx-376ce0571f63c4584373.js"]};/*]]>*/</script><script src="/polyfill-333b796d788154d0324b.js" nomodule=""></script><script src="/component---src-pages-markdown-remark-frontmatter-slug-js-1bc9521777f43783db70.js" async=""></script><script src="/app-5faed1a32dbc85b94cce.js" async=""></script><script src="/framework-5b220df2207acdd267a3.js" async=""></script><script src="/webpack-runtime-7ef62aaed3d55b60f0f0.js" async=""></script></body><script>hljs.highlightAll();</script></html>