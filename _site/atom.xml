<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Ushir (Rishi) Raval</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2021-12-09T23:50:25+02:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Rishi Raval</name>
   <email></email>
 </author>

 
 <entry>
   <title>ABC’s - Deploying Front Ends (featuring EC2)</title>
   <link href="http://localhost:4000/2021/12/09/deploying-frontends/"/>
   <updated>2021-12-09T00:00:00+02:00</updated>
   <id>http://localhost:4000/2021/12/09/deploying-frontends</id>
   <content type="html">&lt;p&gt;With Cloud infrastructure becoming ultra-available, deploying apps have become super easy and as such the deployment/devops space (in my opinion) is going to get pretty interesting in the next few years (since I believe that trivializing the basics makes a breeding ground for creativity). I wanted to document how I’ve been deploying my side projects (very basic apps, prototypes and POCs) for posterity.&lt;/p&gt;

&lt;h2 id=&quot;step-1-prep-your-server&quot;&gt;Step 1: Prep your server&lt;/h2&gt;

&lt;p&gt;Before you think about deploying your app, you need to configure your server. This means:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Getting Nginx or Apache&lt;/li&gt;
  &lt;li&gt;Configuring your ports&lt;/li&gt;
  &lt;li&gt;If deploying multiple apps, configuring a reverse proxy&lt;/li&gt;
  &lt;li&gt;If you have a domain, configuring your DNS and getting SSL certificates for HTTPS&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Points 3 and 4 are out of this scope, but I’ll probably write something about those in the future (tbh, I’m too lazy to get into it now).&lt;/p&gt;

&lt;p&gt;I prefer to use Nginx, just because it’s so much simpler to configure, and allows you to do the reverse proxy-ing much quicker. So this article will focus more on that rather than apache, which is also a fine tool, don’t get me wrong.&lt;/p&gt;

&lt;p&gt;If on ubuntu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-install nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If on EC2 (which I often am) go to the &lt;code&gt;Security Policy&lt;/code&gt; that was configured when you instantiated the server and check out the &lt;code&gt;Outbound&lt;/code&gt; tab. From here you can configure any port you want for TCP or UDP and there is plenty of docs to get you straight for that.&lt;/p&gt;

&lt;p&gt;Your Nginx setup will auto-magically configure your HTTP port for your server (Port 88) and will also use the default folder that is used by Apache 2 by default (more on that later).&lt;/p&gt;

&lt;h2 id=&quot;step-2-build-your-project&quot;&gt;Step 2: Build your project&lt;/h2&gt;

&lt;p&gt;This obviously depends on what framework you use, but most all modern ones use either Webpack, Rollup or something similar under the hood.&lt;/p&gt;

&lt;p&gt;Now all you need to know is that these build tools generate a “bundled” version of your code, which in essence are 1 or 2 files (or a similarly small amount of large files) that contain the entirety of your codebase created in a folder with all your assets (such as images or css and the like). In the case of Typescript projects, this will be compiled down to javascript.&lt;/p&gt;

&lt;p&gt;This “bundle” or file is what your server is concerned with. It’s the deployable artefact that needs to be “published”.&lt;/p&gt;

&lt;p&gt;For Svelte and React:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For Angular 2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ng build .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;step-3-publishing-your-artifacts&quot;&gt;Step 3: Publishing your Artifacts&lt;/h2&gt;

&lt;p&gt;As the heading suggests, you’re now able to get your app onto the server to be accessible from the public url.&lt;/p&gt;

&lt;p&gt;“Publish” in this context (and usually in most situations) just means copying the artefact into a publicly accessible folder, which is the endpoint configured in Apache or Nginx. In linux this is almost always &lt;code&gt;/var/www/html/*&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The simplest, most basic way to do this (in my opinion) is to just FTP into your server and copy the files. In a production environment ideally you’d use a CI/CD-esque tool like AWS Codestar, GitHub Actions or Azure Devops Pipelines, but when you’re just wanting to deploy a small prototype or POC, §“ain’t nobody got time for that”.&lt;/p&gt;

&lt;p&gt;I’ll be using &lt;code&gt;sftp&lt;/code&gt; from the terminal. You can use something like Filezilla or other GUI ftp apps, but I’m lazy and I also don’t like installing extra apps if there’s a perfectly fine solution out of the box.&lt;/p&gt;

&lt;p&gt;If on EC2, change to the directory that contains your &lt;code&gt;public&lt;/code&gt; files (or whatever your framework generated from the previous step) and:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sftp -i &amp;lt;path to your pem key file here&amp;gt; ubuntu@&amp;lt;your EC2 public domain here&amp;gt;:/var/www/html/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you’re using the Amazon Linux image you can substitute &lt;code&gt;ubuntu&lt;/code&gt; for &lt;code&gt;user&lt;/code&gt;. If you don’t know how to get your key file, check out the docs on how to connect with SSH. It’s basically the same process and the pem file works for most everything to do with connecting remotely to your instance.&lt;/p&gt;

&lt;p&gt;Next you want to actually transfer the files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;put -r public/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait for that to complete and then exit &lt;code&gt;sftp&lt;/code&gt; (usually Ctrl-C or &lt;code&gt;exit&lt;/code&gt;) and restart nginx for good measure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo service nginx restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’ve found that restarting nginx will invalidate client side caching so that the user doesn’t have to hard-refresh the browser if they log on with an active cache.&lt;/p&gt;

&lt;h2 id=&quot;closing-remarks&quot;&gt;Closing Remarks&lt;/h2&gt;

&lt;p&gt;There you go. You have an admittedly basic but super (and here ‘super’ means ‘relatively’) pain free prototype that is publicly accessible (or as accessible as you configure the EC2 security policy to be) and easy to run and update. If you’re reading this, hope it helped!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Novel Techniques - Curriculum Learning</title>
   <link href="http://localhost:4000/2021/12/02/curriculum-learning/"/>
   <updated>2021-12-02T00:00:00+02:00</updated>
   <id>http://localhost:4000/2021/12/02/curriculum-learning</id>
   <content type="html">&lt;p&gt;In Neural Network Optimization, most academics have moved on to more novel methods such as Deep Neural Nets and Cascading Networks. However, some techniques can be used to optimise more basic Simple Neural Networks that fall in line with Occam’s Razor. One of them is Curriculum Learning.&lt;/p&gt;

&lt;h2 id=&quot;brief&quot;&gt;Brief&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Occam’s razor, Ockham’s razor, Ocham’s razor (Latin: novacula Occami), also known as the principle of parsimony or the law of parsimony (Latin: lex parsimoniae), is the problem-solving principle that “entities should not be multiplied beyond necessity” - Our trusty pal &lt;a href=&quot;https://en.wikipedia.org/wiki/Occam's_razor&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tl;dr, Occam’s Razor basically says that creating complexity is usually unnecessary and sometimes detrimental to the performance of your system.&lt;/p&gt;

&lt;p&gt;Tl;dr the Tl;dr: Simple is usually best.&lt;/p&gt;

&lt;p&gt;In this case, Curriculum learning aims to improve model performance through a novel training technique that requires an empirical grading of your training data. After all, throwing things at a model and just expecting is to work seems like a very maddening way to get it to perform better (at least to me). This post will by no means be an exhaustive explication of the technique, for that please read one of the papers referenced at the end.&lt;/p&gt;

&lt;h2 id=&quot;understanding-the-basics&quot;&gt;Understanding the Basics&lt;/h2&gt;

&lt;p&gt;Training a Neural Network usually involves:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Data Preparation&lt;/li&gt;
  &lt;li&gt;Training&lt;/li&gt;
  &lt;li&gt;Evaluation&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The latter 2 usually occurring over multiple iterations of the network with different hyperparameters. Curriculum Learning adds a step between 1 and 2 where the data is ‘graded’. There are many formulae that this grading system can use, but I’ll just be mentioning the simplest one here, what I call ‘student’ evaluations, where each set of inputs are graded based on how accurate the model is on it’s first or second pass.&lt;/p&gt;

&lt;h3 id=&quot;the-curriculum&quot;&gt;The ‘Curriculum’&lt;/h3&gt;

&lt;p&gt;This excellent conceptual model of a the training process is from Kwon’s ‘Artificial Neural Networks’ book:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/public/assets/kwon-learning-scheme.png&quot; alt=&quot;Supervised Learning Scheme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This process flow, while very basic, models the portion of the code that feeds in training data as a &lt;em&gt;professor&lt;/em&gt; or teacher and the model is the &lt;em&gt;student&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In Curriculum Learning, the &lt;em&gt;professor&lt;/em&gt; simply creates a structured progression of ‘questions’ (essentially just sets of inputs) and ranks these into blocks segregated by difficulty. Difficulty can be determined by how well the model does on each input after a single (or negligibly few) run(s) with over formulae being proposed across various papers. Easy questions are asked first and after the student ‘gets the hang of those’, it moves on to progressively more difficult problems to solve.&lt;/p&gt;

&lt;p&gt;This is basically a ‘path of least resistance’ and from my experiments, demonstrates a favorable and dramatic increase in performance. For a University Assignment, I had to create a classifier and demonstrate the affects of different training methods on performance, the full report can be seen &lt;a href=&quot;https://github.com/urishiraval/cos711-a2/blob/master/report/output/main.pdf&quot;&gt;here&lt;/a&gt; but long story short,&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;performance was boosted from an average a little above &lt;strong&gt;86% to a steady mean of 97%&lt;/strong&gt; (with a low standard deviation across runs for both models) &lt;strong&gt;even reaching 99% accuracy&lt;/strong&gt; boasting very impressive lack of loss with (what I perceived to be) very little over-fitting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;downsides&quot;&gt;Downsides&lt;/h3&gt;

&lt;p&gt;The first issue is the matter of grading. This requires some form of intimacy with the data before training and if the data is graded poorly or not properly split up, or if the training speed is too fast or too slow, it may have no effect. Thus we’ve introduced even more annoying hyperparamters to the mix.&lt;/p&gt;

&lt;p&gt;The second issue makes the first one even more annoying. This method increases learning time significantly (and here ‘significantly’ is an understatement), which might not be feasible for larger models and make tuning much more tedious.&lt;/p&gt;

&lt;h2 id=&quot;in-conclusion&quot;&gt;In Conclusion&lt;/h2&gt;

&lt;p&gt;This is a cool way (at least to me) to train NN’s and it has a lot of benefits, especially with smaller models. This might also give you a way to get out of a plateau that you may be facing with your model and we all know how annoying those can be. If you’re reading this, hope it helps!&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;G. Hacohen and D. Weinshall, “On the power of curriculum learning in
training deep networks,” 2019.&lt;/li&gt;
  &lt;li&gt;Kwon SJ. Artificial Neural Networks. Nova Science Publishers, Inc; 2011. Accessed December 2, 2021.&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Starting from Scratch - Fluent Validation</title>
   <link href="http://localhost:4000/2021/08/23/fluent-validation-1/"/>
   <updated>2021-08-23T00:00:00+02:00</updated>
   <id>http://localhost:4000/2021/08/23/fluent-validation-1</id>
   <content type="html">&lt;p&gt;In an attempt to further understand how fluent validation works in javascript, I tried to recreate an extremely basic chain-able system from scratch.&lt;/p&gt;

&lt;h2 id=&quot;brief&quot;&gt;Brief&lt;/h2&gt;

&lt;p&gt;The main goal of fluent validation seems to be the separation of highly conditional branching trees into it’s own layer in very dynamic systems. So far the only system that I’ve worked on where this would be of great benefit are business/financial applications with a ton of business/product rules and while ideally you’d want those rules to be evaluated in the back-end I think that the front-end (especially if it’s a monolithic front end, which is often the case in that environment) can get very dense with dynamic content depending on those rules.&lt;/p&gt;

&lt;p&gt;I’m still searching for the “simplest form of this” with the “most substantial outcome” as Liebniz describes it, but I think that fluent validation is the strongest contender so far.&lt;/p&gt;

&lt;h2 id=&quot;understanding-the-basics&quot;&gt;Understanding the Basics&lt;/h2&gt;

&lt;p&gt;First, I researched different ways that function chaining was accomplished and ultimately found &lt;a href=&quot;https://stackoverflow.com/questions/35026609/chain-custom-javascript-functions&quot;&gt;this Stackoverflow post&lt;/a&gt; from 2016. In that post I found that there are 2 basic approuches that are pretty much similar in concept but with slightly different executions.&lt;/p&gt;

&lt;h3 id=&quot;chaining-in-javascript&quot;&gt;Chaining in Javascript&lt;/h3&gt;

&lt;p&gt;Before that however, I needed to define what was the minium requirement for a function to be chained. So this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function chainableX () {
    console.log(&quot;Executing X&quot;);
    return this;
}

function chainableY() {
    console.log(&quot;Executing Y&quot;);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Would allow us to ‘chain’ like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var context = chainableX().chainableY();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Executing X
Executing Y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where the resulting &lt;code&gt;context&lt;/code&gt; variable would be the global call stack since these functions don’t belong to any object.So, with that, returning &lt;code&gt;this&lt;/code&gt; I could now chain functions.&lt;/p&gt;

&lt;h3 id=&quot;accumulating-side-effects-within-a-scope&quot;&gt;Accumulating Side-effects within a Scope&lt;/h3&gt;

&lt;p&gt;The next task was to allow for side effects to accumulate in a sequential manner. My initial thoughts were that this was very similar to a ‘Builder’ design pattern and indeed, when I glanced at the source code of some common validation packages, that seemed to be a solution that was used. However, in my attempt to keep things as simple as I possibly can, along with trying to use vanilla js and functional-ish concepts as much as I can, I opted for a slightly different approach, (but one that was not necessarily better by any metric).&lt;/p&gt;

&lt;p&gt;My first attempt was to create an ‘object’ based solution that would accumulate the side effects on a variable within that context. So I thought that the initial object would somehow resemble this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;check = {
    result: null,
    not: function() {
        this.result = !this.result;
        return this;
    },
    or: function() {
        return this;
    },
    and: function() {
        return this;
    },
    t: function() {
        return this;
    },
    f: function() {
        return this;
    }
}

console.log(check.not().f().and().t().result);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;chaining-of-boolean-operators&quot;&gt;Chaining of Boolean Operators&lt;/h3&gt;

&lt;p&gt;I quickly realised that I’d have a glaring problem. The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are binary and while this gives the example chain above a ‘space’ to accumulate results, you can’t accumulate a binary operator without ‘embedding’ values similar to &lt;code&gt;check.not().and(&amp;lt;exp&amp;gt;)&lt;/code&gt;, which was not what I wanted.&lt;/p&gt;

&lt;p&gt;So in order to solve this problem I decided to borrow from my Compiler Construction course in University by adding very basic ‘lookahead’ functionality.&lt;/p&gt;

&lt;p&gt;Fundamentally, what this lookahead function would do is defer the binary operation until a subsequent unary operation has a result (kind of like the ‘Chain of responsibility’ design pattern). This is a bit of a dodgy solution which, I think, only works because chaining multiple binary operations have no value in a validation, i.e. &lt;code&gt;and().and().t()&lt;/code&gt; makes no logical sense in boolean terms and adds no functional value.&lt;/p&gt;

&lt;p&gt;So, adding this lookahead function as _la and just concentrating on &lt;code&gt;AND&lt;/code&gt;, we get the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;check = {
    _la: null,
    and: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result;
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res &amp;amp;&amp;amp; exp;
        };
        return this;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding some ‘constants’ like true and false, along with a ‘default lookahead’ function in order to cater for when our lookahead is null we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;check = {
    _la: null,
    _defaultLa: function(exp) {
        //Just pass through the value
        return exp;
    },
    and: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result;
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res &amp;amp;&amp;amp; exp;
        };
        return this;
    },
    tautology: function() {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(true);
        this._la = null;
        return this;
    },
    fallacy: function () {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(false);
        this._la = null;
        return this;
    }
}

console.log(check.tautology().and().tautology().result);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All that is left to do is to extend this concept to the &lt;code&gt;OR&lt;/code&gt; and &lt;code&gt;NOT&lt;/code&gt; operators. However the &lt;code&gt;NOT&lt;/code&gt; operator, despite being a unary operator, still needs to be implemented as a deferred operation since we’re negating the result of the operation after it, i.e. we need it to look like &lt;code&gt;not().operation()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The resulting snippet becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;check = {
    result: null,
    _la: null,
    _defaultLa: function(exp) {
        //Just pass through the value
        return exp;
    },
    not: function() {
        var eval = (this._la) ? this._la : this._defaultLa;
        var res = this.result;
        this._la = function(exp) {
            //We pass in eval to the function stack by taking advantage of javascript closures
            return eval(!exp);
        }
        return this;
    },
    and: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result;
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res &amp;amp;&amp;amp; exp;
        };
        return this;
    },
    or: function() {
        //if a lookahead is already waiting to be executed we can automatically say that the previous operator was binary
        if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
        //This is just to allow for closure resolution to ensure that the function will retain the correct value of result
        let res = this.result;
        //The Looahead function in question. 'exp' is the result of a subsequent unary operation
        this._la = function(exp) {
            return res || exp;
        };
        return this;
    },
    tautology: function() {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(true);
        this._la = null;
        return this;
    },
    fallacy: function () {
        var eval = (this._la) ? this._la : this._defaultLa;
        this.result = eval(false);
        this._la = null;
        return this;
    }
}

console.log(check.fallacy().or().not().fallacy().result);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there you have it. This is a working, chainable, admittedly ultra-basic fluent validator that you can extent by adding more operators and dependant objects etc.&lt;/p&gt;

&lt;h3 id=&quot;final-product&quot;&gt;Final Product&lt;/h3&gt;

&lt;p&gt;However, to make it a bit more usable and extendable I thought converting this to a context-full, generic-ish object would be better:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function fcheck() {
        this.result = null;
        this._la = null;
        this._defaultLa = function(exp) {
            return exp;
        };
        this._preval = function (exp) {
            var eval = (this._la) ? this._la : this._defaultLa;
            this.result = eval(exp);
        };
        this.not = function() {
            var eval = (this._la) ? this._la : this._defaultLa;
            this._la = function(exp) {
                //We pass in eval to the function stack by taking advantage of javascript closures
                return eval(!exp);
            }
            return this;
        };
        this.or = function() {
            if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
            let res = this.result;
            this._la = function(exp) {
                return res || exp;
            }
            return this;
        };
        this.and = function() {
            if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
            let res = this.result;
            this._la = function(exp) {
                return res &amp;amp;&amp;amp; exp;
            };
            return this;
        };
        this.tautology = function() {
            this._preval(true);
            this._la = null;
            return this;
        };
        this.fallacy = function() {
            this._preval(false);
            this._la = null;
            return this;
        }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to dynamically add rules on the fly by adding to the object, this function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;fcheck.prototype.addRule = function (ruleName, rule) {
    var acc = this;
    this[ruleName] = function () {
        this._preval(rule());
        return acc;
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;So the final version:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function fcheck() {
        this.result = null;
        this._la = null;
        this._defaultLa = function(exp) {
            return exp;
        };
        this._preval = function (exp) {
            var eval = (this._la) ? this._la : this._defaultLa;
            this._la = null;
            this.result = eval(exp);
        };
        this.not = function() {
            var eval = (this._la) ? this._la : this._defaultLa;
            this._la = function(exp) {
                return eval(!exp);
            }
            return this;
        };
        this.or = function() {
            if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
            let res = this.result;
            this._la = function(exp) {
                return res || exp;
            }
            return this;
        };
        this.and = function() {
            if (this._la) throw &quot;Chaining multiple binary operators is not allowed&quot;;
            let res = this.result;
            this._la = function(exp) {
                return res &amp;amp;&amp;amp; exp;
            };
            return this;
        };
        this.tautology = function() {
            this._preval(true);
            return this;
        };
        this.fallacy = function() {
            this._preval(false);
            return this;
        }
}

fcheck.prototype.addRule = function (ruleName, rule) {
    var acc = this;
    this[ruleName] = function () {
        this._preval(rule());
        return acc;
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this object can be used like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var scenario = new fcheck();
scenario.addRule(&quot;myFunction&quot;, function () {
    return true;
});

scenario.not().myFunction().and().fallacy().result;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also allows us to compose complex validations, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var flagA = true;
var flagB = false;

var Rule1 = new fcheck().addRule(&quot;isScenarioA&quot;, function () {
    return flagA == true;
});
var Rule2 = new fcheck().addRule(&quot;isScenarioA&quot;, function () {
    return flagB == true;
});

var BusinessValidations = new fcheck().addRule('rule1', function () {
    return Rule1.isScenarioA().result;
})
.addRule('rule2', function () {
    return Rule2.isScenarioA().result;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;BusinessValidations.rule1().and().rule2().result;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;BusinessValidations.rule1().and().not().rule2().result;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that’s it. Thanks for sticking around to this sentence. If you, the reader, has any thoughts on this implementation or a better way to do this (besides just using a library…I do know that I can and that’s not the point here), please do reach out and let me know on my socials found somewhere on this site.&lt;/p&gt;
</content>
 </entry>
 

</feed>
